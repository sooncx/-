<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
</head>

<body>
    <div id="obj1">
        <h5>1</h5>
        <h5>2</h5>
        <h5>3</h5>
        <h5>4</h5>
        <h5>5</h5>
    </div>
</body>

</html>
<script>
    var obj1 = document.getElementById("obj1");
    obj1.addEventListener(
        "click",
        function (e) {
            var e = e || window.event;
            //上面代码的用意，为何能实现兼容
            // function (event) {
            //         var e=event?event||window.event;
            // }
            //如果存在event,那么var e=event;而如果不存在event，那么var e=window.event
            if (e.target.nodeName.toLowerCase() == "h5") {
                alert(e.target.innerHTML);
            }
        },
        false
    );
</script>
<!-- arguments 是JavaScript里的一个内置对象,有的函数都有属于自己的一个arguments对象，它包括了函所要调用的参数。object对象。
比如：
function t(){
  alert(arguments[0]);//显示t函数的输入参数，这里是2
}
t('2');//调用函数，传入参数2 -->

<!-- 用this.$refs.******.focus()来使得用户名，密码未输入时候，回车或点击登录后获取焦点 -->
<!-- 直接在data（）{}存放的数据是全局变量，其他组件也可以引用，在data（）{return{}} 里面写的就是只能在本组件使用的数据 -->
<!-- watch:{
    firstname:function(newValue,OldValue){
      console.log(newValue);
      console.log(OldValue);
    }
  }
其中第一个参数是新值，第二个参数是旧值 -->

<!-- hellowwwokkk -->
<!-- str.split("o")将字符串str按o分割为一个数组[hell,www,kkk];
str.split("o")[1] == www;
str.split("o")[0] == hell; -->
<!-- 
var xiaoming = {
    name: "cx",
    birth: 1999,
    sex: "man",
    age: function() {
        this.birth//能获取
        function getage() {
            var y = new Date.getFullYear();
            return y - this.birth;//windows.birth获取不到
        }
        return getage();
    }
};
xiaoming.age();//报错
原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数getage的this是underfined或windows；
即在age函数内this指向对象小明，在age函数内又定义函数getage，getage函数内的this指向windows或underfined


解决方法是在age函数内获取当前this，再传递给内部函数，如下
var xiaoming = {
    name: "cx",
    birth: 1999,
    sex: "man",
    age: function() {
        var that = this;//当前this赋值给that；
        function getage() {
            var y = new Date.getFullYear();
            return y - that.birth;
        }
        return getage();
    }
}; -->
<!-- 或者 -->
<!-- var xiaoming = {
    name: "cx",
    birth: 1999,
    sex: "man",
    age: function() {
        function getage() {
            var y = new Date.getFullYear();
            return y - this.birth;
        }
        return getage.apply(this);
    }
}; -->
<!-- map() 和 reduce()
map()传入的参数是function，即函数对象本身。
function fun() {
    return x*x;
}
arr = [1,2,3,4];
arr.map(fun)//[1,4,9,16];

reduce()
Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是：
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4);

arr = [1,2,3,4]

arr.reduce(function(x,y) {
    return x*10 + y;
})//1234
即是((1*10+2)*10 + 3)*10 +4 = 1234; -->
<!-- 
Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素

arr = [1,2,3,4,5];

arr.filter(function(x) {
    return x%2 === 0;//偶数
})//2,4

arr.filter(function(element,index,self) {
    element就是arr的每个元素
    index就是arr每个元素的索引值
    self就是arr本身
})
用fliter数组去重

arr.filter(function(element,index,self) {
    return self.indexOf(element) === index;
}) -->

<!-- forEach
不能中断循环(使用break语句或使用return语句）。
let arr = ['a', 'b', 'c', 'd']
arr.forEach(function (val, index, arr) {
    console.log(val + ', index = ' + index) // val是当前元素，index当前元素索引，arr数组
    console.log(arr)
})

a, index = 0
(4) ["a", "b", "c", "d"]
b, index = 1
(4) ["a", "b", "c", "d"]
c, index = 2
(4) ["a", "b", "c", "d"]
d, index = 3
(4) ["a", "b", "c", "d"] -->

<!-- for…in
for-in循环实际是为循环”enumerable“对象而设计的

let obj = {a: '1', b: '2', c: '3', d: '4'}
for (let o in obj) {
    console.log(o)    //遍历的实际上是对象的属性名称 a,b,c,d
    console.log(obj[o])  //这个才是属性对应的值1，2，3，4
} 

let arr = [1,2,3,4]
for(let i in arr) {
    console.log(i)  //输出索引值0,1,2,3
    console.log(arr[i])  //输出1,2,3,4
}
-->

<!-- 
    for…of
它是ES6中新增加的语法 
循环一个数组

let arr = ['China', 'America', 'Korea']
for (let o of arr) {
    console.log(o) //China, America, Korea
}
但是它并不能循环一个普通对象

let obj = {a: '1', b: '2', c: '3', d: '4'}
for (let o of obj) {
    console.log(o)   //Uncaught TypeError: obj[Symbol.iterator] is not a function
}
 -->

<!-- 
     但是可以循环一个拥有enumerable属性的对象。 
如果我们按对象所拥有的属性进行循环，可使用内置的Object.keys()方法

let obj = {a: '1', b: '2', c: '3', d: '4'}
for (let o of Object.keys(obj)) {
    console.log(o) // a,b,c,d
}

如果我们按对象所拥有的属性值进行循环，可使用内置的Object.values()方法

let obj = {a: '1', b: '2', c: '3', d: '4'}
for (let o of Object.values(obj)) {
    console.log(o) // 1,2,3,4
}

循环一个字符串

let str = 'love'
for (let o of str) {
    console.log(o) // l,o,v,e
}

循环一个Map

let iterable = new Map([["a", 1], ["b", 2], ["c", 3]]);

for (let [key, value] of iterable) {
  console.log(value);
}
// 1
// 2
// 3

for (let entry of iterable) {
  console.log(entry);
}
// [a, 1]
// [b, 2]
// [c, 3]

循环一个Set

let iterable = new Set([1, 1, 2, 2, 3, 3]);

for (let value of iterable) {
  console.log(value);
}
// 1
// 2
// 3

循环一个类型化数组

let iterable = new Uint8Array([0x00, 0xff]);

for (let value of iterable) {
  console.log(value);
}
// 0
// 255
  -->


<!-- 
1、Map 
Map是一组键值对的结构，初始化Map需要一个二维数组或者直接初始化一个空Map。

var map1 = new Map(); // 初始化一个空Map
var map2 = new Map([['name','小悦'],['age',23],['sex','女']]); // 用二维数组初始化一个Map
map2.set('home','河南'); // 增
map2.delete('name'); // 删
map2.get('age'); // 查
map2.has('sex') // 是否存在key


2、Set 
Set是一组只含有key的集合，初始化Set需要一个数组或者直接初始化一个空Set。

var set1 = new Set(); // 初始化一个空Set
var set2 = new Set([1,2,3]); // 用一维数组初始化一个Set
set1.add(4); // 增
set1.delete(4); // 删

key不能重复，所以Set没有重复的元素
   -->